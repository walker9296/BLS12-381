contract Test {

    static const int p = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab;

    static const int UB = 548;


    function modReduce(int k, int modulus) : int {
        int res = k % modulus;
        return (res < 0) ? res + modulus : res;
    }

    function modInverseEGCD(int x, int n) : int {
        // The following script already does modular reduction at the start so there's no
        // need to normalize x before function call.
        asm {
            OP_2DUP OP_MOD OP_DUP OP_0 OP_LESSTHAN OP_IF OP_DUP OP_2 OP_PICK OP_ADD OP_ELSE OP_DUP OP_ENDIF OP_NIP OP_2 OP_ROLL OP_DROP
            OP_DUP OP_TOALTSTACK OP_TOALTSTACK OP_TOALTSTACK
            OP_1 OP_0 OP_1
            loop(UB) {
                OP_FROMALTSTACK OP_FROMALTSTACK OP_2DUP OP_DUP OP_IF OP_TUCK OP_MOD OP_TOALTSTACK OP_TOALTSTACK OP_DIV OP_MUL OP_SUB OP_TUCK OP_ELSE OP_TOALTSTACK OP_TOALTSTACK OP_DROP OP_DROP OP_ENDIF
            }
            OP_FROMALTSTACK OP_FROMALTSTACK OP_DROP OP_DROP OP_DROP OP_FROMALTSTACK OP_SWAP OP_NIP
        }
    }

    public function test(int x) {
        int inv = this.modInverseEGCD(x, p);
        require(this.modReduce(inv * x, p) == 1);
    }

    public function testModInverseEGCD() {
        int inv = this.modInverseEGCD(77777777777777, p);
        require(this.modReduce(inv * 77777777777777, p) == 1);
    }
}