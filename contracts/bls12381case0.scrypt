import "bls12381.scrypt";


contract bls12381testcase0 {
/*
   public function testMod() {
        int c = BLS12381.mod(2, 3);
        require(c == 2);
        c = BLS12381.mod(5, 3);
        require(c == 2);
        c = BLS12381.mod(-1, 3);
        require(c == 2);
    }
 
    public function testToMont_FromMont() {
        fe a0 = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaaa;
        fe a1 = 0x040ab3263eff0206ef148d1ea0f4c069eca8f3318332bb7a07e83a49a2e99d6932b7fff2ed47fffd43f5fffffffcaaae;
        fe a2 = BLS12381.toMont(a0);
        require(a1 == a2);
        fe d = BLS12381.fromMont(a2);
        require(d == a0);

        fe e = BLS12381.fromMont(BLS12381.r1);
        require(e == 1);

        fe f1 = 0x15f65ec3fa80e4935c071a97a256ec6d77ce5853705257455f48985753c758baebf4000bc40c0002760900000002fffd;
        fe f2 = BLS12381.fromMont(BLS12381.r2);
        require(f1 == f2);

        fe g1 = 0x14fec701e8fb0ce9ed5e64273c4f538b1797ab1458a88de9343ea97914956dc87fe11274d898fafbf4d38259380b4820;
        fe g2 = BLS12381.fromMont(1);
        require(g1 == g2);
    }
*/
    public function testP() {
        fe ff = BLS12381.modInverseBranchlessP(BLS12381.r1);
        // fe ff = BLS12381.inverse(BLS12381.r1);
        fe f2 = BLS12381.mod(ff, BLS12381.P);
        fe f3 = BLS12381.fromMont(f2);
        fe f4 = BLS12381.toMont(f2);
        bytes t3a = reverseBytes(num2bin(ff, 48), 48);      
        bytes t3b = reverseBytes(num2bin(f2, 48), 48);      
        bytes t3c = reverseBytes(num2bin(f3, 48), 48);      
        bytes t4c = reverseBytes(num2bin(f4, 48), 48);      
        require(ff == 0x15f65ec3fa80e4935c071a97a256ec6d77ce5853705257455f48985753c758baebf4000bc40c0002760900000002fffd);

        require(true);
    }

}